<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Gesture Particle System</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(31, 41, 55, 0.95);
            padding: 20px;
            border-bottom: 2px solid #4b5563;
            z-index: 10;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .icon {
            width: 24px;
            height: 24px;
        }
        
        #templateButtons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .template-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            background: #374151;
            color: #d1d5db;
        }
        
        .template-btn:hover {
            background: #4b5563;
        }
        
        .template-btn.active {
            background: #9333ea;
            color: white;
        }
        
        .instructions {
            color: #d1d5db;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .instructions p {
            margin: 5px 0;
        }
        
        #videoContainer {
            position: absolute;
            top: 180px;
            right: 20px;
            width: 240px;
            height: 180px;
            border: 3px solid #9333ea;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            z-index: 5;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: #10b981;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 5;
        }
        
        .pulse {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            z-index: 20;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h1>
                <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"></path>
                </svg>
                Hand Gesture Particle System
            </h1>
            
            <div id="templateButtons">
                <button class="template-btn active" onclick="changeTemplate('hearts')">Hearts</button>
                <button class="template-btn" onclick="changeTemplate('flowers')">Flowers</button>
                <button class="template-btn" onclick="changeTemplate('saturn')">Saturn</button>
                <button class="template-btn" onclick="changeTemplate('fireworks')">Fireworks</button>
                <button class="template-btn" onclick="changeTemplate('spiral')">Spiral</button>
                <button class="template-btn" onclick="changeTemplate('cube')">Cube</button>
            </div>
            
            <div class="instructions">
                <p>ü§è <strong>Pinch gesture</strong> (thumb + index finger): Control particle expansion</p>
                <p>‚úã <strong>Hand height</strong>: Change particle colors</p>
                <p>üëÜ <strong>Click buttons</strong>: Switch between particle templates</p>
            </div>
        </div>
        
        <div id="videoContainer">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas" width="640" height="480"></canvas>
        </div>
        
        <div id="status" class="hidden">
            <div class="pulse"></div>
            Camera Active
        </div>
        
        <div id="loading">Loading hand tracking...</div>
    </div>

    <script>
        let scene, camera, renderer, particleSystem;
        let hands;
        let particleGeometry, particleMaterial;
        const particleCount = 2000;
        let targetPositions = [];
        let currentPositions = [];
        let currentTemplate = 'hearts';

        // Particle templates
        const templates = {
            hearts: () => {
                const positions = [];
                for (let i = 0; i < particleCount; i++) {
                    const t = (i / particleCount) * Math.PI * 2;
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    positions.push(x / 10, y / 10, (Math.random() - 0.5) * 2);
                }
                return positions;
            },
            flowers: () => {
                const positions = [];
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = Math.sin(angle * 5) * 2 + 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    positions.push(x, y, (Math.random() - 0.5) * 1);
                }
                return positions;
            },
            saturn: () => {
                const positions = [];
                const sphereCount = Math.floor(particleCount * 0.6);
                const ringCount = particleCount - sphereCount;
                
                for (let i = 0; i < sphereCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 1.5;
                    positions.push(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                }
                
                for (let i = 0; i < ringCount; i++) {
                    const angle = (i / ringCount) * Math.PI * 2;
                    const radius = 2.5 + Math.random() * 0.5;
                    positions.push(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 0.2,
                        Math.sin(angle) * radius
                    );
                }
                return positions;
            },
            fireworks: () => {
                const positions = [];
                const bursts = 5;
                const perBurst = Math.floor(particleCount / bursts);
                
                for (let b = 0; b < bursts; b++) {
                    const centerX = (Math.random() - 0.5) * 4;
                    const centerY = (Math.random() - 0.5) * 4;
                    const centerZ = (Math.random() - 0.5) * 4;
                    
                    for (let i = 0; i < perBurst; i++) {
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        const r = Math.random() * 2;
                        positions.push(
                            centerX + r * Math.sin(phi) * Math.cos(theta),
                            centerY + r * Math.sin(phi) * Math.sin(theta),
                            centerZ + r * Math.cos(phi)
                        );
                    }
                }
                return positions;
            },
            spiral: () => {
                const positions = [];
                for (let i = 0; i < particleCount; i++) {
                    const t = (i / particleCount) * Math.PI * 8;
                    const r = t * 0.3;
                    positions.push(
                        Math.cos(t) * r,
                        (i / particleCount) * 6 - 3,
                        Math.sin(t) * r
                    );
                }
                return positions;
            },
            cube: () => {
                const positions = [];
                const size = 3;
                for (let i = 0; i < particleCount; i++) {
                    positions.push(
                        (Math.random() - 0.5) * size,
                        (Math.random() - 0.5) * size,
                        (Math.random() - 0.5) * size
                    );
                }
                return positions;
            }
        };

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [r, g, b];
        }

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
                
                colors[i * 3] = 1;
                colors[i * 3 + 1] = 0.5;
                colors[i * 3 + 2] = 0.8;
                
                sizes[i] = Math.random() * 3 + 1;
            }

            currentPositions = Array.from(positions);
            targetPositions = templates.hearts();

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                sizeAttenuation: true
            });

            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        async function initCamera() {
            const video = document.getElementById('video');
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: 640, height: 480 } 
            });
            video.srcObject = stream;
            
            document.getElementById('status').classList.remove('hidden');
        }

        function onResults(results) {
            const canvas = document.getElementById('canvas');
            const canvasCtx = canvas.getContext('2d');
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            canvasCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, 
                        { color: '#00FF00', lineWidth: 2 });
                    drawLandmarks(canvasCtx, landmarks, 
                        { color: '#FF0000', lineWidth: 1 });

                    const palm = landmarks[0];
                    const indexTip = landmarks[8];
                    const thumbTip = landmarks[4];
                    
                    const distance = Math.sqrt(
                        Math.pow(indexTip.x - thumbTip.x, 2) +
                        Math.pow(indexTip.y - thumbTip.y, 2)
                    );

                    const scale = Math.max(0.5, Math.min(3, (distance / 0.1) * 2));
                    
                    const positions = particleGeometry.attributes.position.array;
                    for (let i = 0; i < particleCount; i++) {
                        const tx = targetPositions[i * 3] * scale;
                        const ty = targetPositions[i * 3 + 1] * scale;
                        const tz = targetPositions[i * 3 + 2] * scale;
                        
                        currentPositions[i * 3] += (tx - currentPositions[i * 3]) * 0.1;
                        currentPositions[i * 3 + 1] += (ty - currentPositions[i * 3 + 1]) * 0.1;
                        currentPositions[i * 3 + 2] += (tz - currentPositions[i * 3 + 2]) * 0.1;
                        
                        positions[i * 3] = currentPositions[i * 3];
                        positions[i * 3 + 1] = currentPositions[i * 3 + 1];
                        positions[i * 3 + 2] = currentPositions[i * 3 + 2];
                    }
                    particleGeometry.attributes.position.needsUpdate = true;

                    const hue = palm.y;
                    const colorArray = particleGeometry.attributes.color.array;
                    for (let i = 0; i < particleCount; i++) {
                        const h = hue * 360;
                        const rgb = hslToRgb(h / 360, 1, 0.6);
                        colorArray[i * 3] = rgb[0];
                        colorArray[i * 3 + 1] = rgb[1];
                        colorArray[i * 3 + 2] = rgb[2];
                    }
                    particleGeometry.attributes.color.needsUpdate = true;
                }
            }
            canvasCtx.restore();
        }

        async function initHands() {
            const video = document.getElementById('video');
            
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            const sendFrame = async () => {
                if (video.readyState === 4) {
                    await hands.send({ image: video });
                }
                requestAnimationFrame(sendFrame);
            };
            sendFrame();

            document.getElementById('loading').classList.add('hidden');
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (particleSystem) {
                particleSystem.rotation.y += 0.002;
            }
            
            renderer.render(scene, camera);
        }

        function changeTemplate(template) {
            currentTemplate = template;
            targetPositions = templates[template]();
            
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const buttons = document.querySelectorAll('.template-btn');
            buttons.forEach(btn => {
                if (btn.textContent.toLowerCase() === template) {
                    btn.classList.add('active');
                }
            });
        }

        async function init() {
            initThree();
            await initCamera();
            await initHands();
            animate();
        }

        init();
    </script>
</body>
</html>